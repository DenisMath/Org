Язык программирования Postscript предназначен для формирования рисунков в формате .ps и .eps
* Структура документа

Структура файла PostScript формируется структурными комментариями. Структурные комментарии начинаются с последовательности символов «%%» в начале строки.
Файл PostScript состоит из четырёх частей: заголовка, пролога, тела и эпилога.
Заголовок начинается строкой «%!PS-Adobe-N.M» где N.M — версия спецификации, далее идут структурные комментарии с общими свойствами документа, и заканчивается заголовок строкой «%%EndComments».

%!PS-Adobe-3.0
%%Title:   название проекта
%%Creator:   создатель файла
%%CreationDate:   дата_и_время_создания
%%For:   указание для кого создан файл
%%Copyright:   фирма или автор, имеющий права на файл
%%Document fonts:   имена используемых фонтов
%%BoundingBox: 0 0 596 843
%%Pages: 10
%%EndComments
%%BeginProcSet
      текст процедур
%%EndProcSet
%%EndProlog
%%Page i 1
      команды описания первой страницы
  showpage
%%Page ii 2
      команды описания второй страницы
  showpage
            и так далее
%%Trailer
%%EOF 

Структура eps файла:
%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: 20 20 800 600
%%EndComments
%%BeginProcSet
      текст процедур
%%EndProcSet
%%EndProlog
  gsave
      команды описания картинки
  grestore
  showpage
%%Trailer
%%EOF 

В прологе обычно содержатся описания подпрограмм и данные, необходимые для печати документа — например, процедуры и шрифты. Пролог заканчивается комментарием «%%EndProlog».
В теле программы содержатся команды, отвечающие за отрисовку каждой страницы, предваряемые строкой «%%Page: <метка> <номер>», где <метка> — метка страницы, которая не выводится на печать, и <номер> — порядковый номер страницы в файле, например, %%Page: iii 3
После команд отрисовки всех страниц идёт структурный комментарий «%%Trailer», после чего начинается эпилог.
В эпилоге можно продублировать комментарии из заголовка (это реализовано на случай, если в начале вывода программе ещё не известно, например, число страниц) — в этом случае вместо числовых значений параметров в заголовке надо писать «(atend)».
Заканчивается файл строкой «%%EOF».

* Команды
showpage - эта команда указывает интерпретатору, что больше команд не будет и страница полностью описана, и приказывает начать переводить описание в растровую картинку, которая и будет показана на экране.

В общем случае определение процедуры записывается следующим образом - /name {процедура как кусок программы} def 

/name {процедура как кусок программы} bind def - если в теле процедуры есть имена других процедур, тогда они сразу заменяются на свои процедуры с тем, чтобы ускорить работу программы в последующем. 

add -- вынимает два числа из стека, складывает их и возвращает их сумму

sub -- вынимает два числа из стека, вычитает их и возвращает их разность

mul -- вынимает два числа из стека, умножает их и возвращает их произведение

div -- вынимает два числа из стека, делит их и возвращает их частное

idiv -- вынимает два целых числа из стека, делит их и возвращает целое частное

mod -- вынимает два числа из стека, делит их и возвращает остаток от деления 

abs -- абсолютное значение

neg -- изменение знака числа

ceiling -- ближайшее целое сверху

floor -- ближайшее целое снизу

round -- ближайшее целое с меньшим расстоянием

truncate -- дробная часть числа

sqrt -- квадратный корень

atan -- берет два числа из стека и возврашает арктангенс их отношения в градусах

cos -- косинус числа в градусах

sin -- синус числа в градусах

exp -- берет два числа и возвышает предпоследнее в степень последнего

log -- десятичный логарифм

ln -- натуральный логарифм

rand -- ничего не берет но возвращает в стек случайное целое число

srand -- берет из стека целое число и устанавливает как базовое в последовательности случайных чисел

rrand -- ничего не берет и устанавливает базовое число в последовательности случайных чисел 

exch --  меняет местами последние два объекта в стеке.

* Команды рисования

newpath -- открывает новую траекторию как объект. Курсор пока остается на старом месте.

closepath -- закрывает траекторию как объект, при этом дорисовывается линия, соединяющая последнюю точку с первой точкой траектории и траектория становится замкнутой.

moveto -- берет из стека два числа (сначала Y потом X) и переносит курсор в точку с данными координатами. При этом траектория не меняется (перо над бумагой). Эта команда фактически задает первую точку новой траектории.

rmoveto -- то же, что и предыдущая команда, только в стеке не абсолютные координаты X,Y, а смещения DX,DY курсора из текущей точки в новую точки. Если исходно курсор находился в точке с координатами 0,0, то эта команда эквивалентна предыдущей. Однако иногда надо начать новую траекторию на определенном расстоянии от предыдущей траектории. Тогда эта команда упрощает расчеты.

lineto -- берет из стека два числа (сначала Y потом X) и добавляет к траектории отрезок прямой линии из предыдущей точки в точку с данными координатами.

rlineto -- то же, что и предыдущая команда, только в стеке не абсолютные координаты X,Y, а смещения DX,DY курсора из текущей точки в новую точки.

curveto -- берет из стека шесть чисел (Y3,X3,Y2,X2,Y1,X1) и добавляет к траектории отрезок кривой линии из текущей точки в точку X3,Y3 как кубический сплайн. Точки X1,Y1,X2,Y2 на траектории не находятся, они используются для интерполяции. Так прямая из текущей точки в точку X1,Y1 задает начальную ориентацию кривой, а прямая из точки X2,Y2 в точку X3,Y3 - конечную ориентацию кривой. Это достаточно сложная команда, она может быть использована в чертежах для сглаживания острых углов на траектории.

rcurveto -- то же, что и предыдущая команда, только в стеке не абсолютные координаты X,Y, а смещения DX,DY курсора из текущей точки в новые точки.

arc -- берет из стека пять чисел (A2,A1,R,Y,X) и добавляет к траектории отрезок кривой линии как часть окружности (дуги) с центром в точке X,Y и с радиусом R. Углы A1 и A2 в градусах задают начало и конец дуги. Движение против часовой стрелки. Для рисования полной окружности достаточно задать A1=0, A2=360.

acrn -- то же, что и предыдущая команда, только движение по часовой стрелке.

arct -- берет из стека пять чисел (R,Y2,X2,Y1,X1) и добавляет к траектории отрезок кривой линии как часть окружности (дуги) с радиусом R, которая имеет своими касательными отрезки прямых линий из текущей точки в X1,Y1 и из X1,Y1 в X2,Y2. Траектория заканчивается в точке X2,Y2. 

setrgbcolor -- берет из стека три числа (B,G,R) и задает текущий цвет для рисования всего как комбинацию трех цветов - красного (R), зеленого (G) и синего (B). Это стандартный способ задания цвета. Важно только помнить, что числа задаются в диапазоне от 0 (отсутствие) до 1 (полная яркость). Так что черный нужно задавать как 0 0 0 а белый как 1 1 1.

setgray -- берет из стека одно число G и задает яркость серого. Эта команда первоначально была создана для черно-белых принтеров, но она остается и сейчас и часто используется. Дело в том, что черно-белые графики еще часто создаются, например в публикациях научных статей. Фактически команда G setgray эквивалентна команде G G G setrgbcolor.

setlinewidth -- берет из стека одно число W и задает толщину рисования линий по контуру.

setlinejoin -- берет из стека одно число N и задает модификацию обработки углов ломаной толстой линии. Есть три способа: N=0 реальный угол как есть, N=1 сглаженный угол по дуге, N=2 обрезаный угол.

setlinecap -- берет из стека одно число N и задает модификацию обработки концов толстой линии. Есть три способа: N=0 укороченный конец (точно по контуру), N=1 сглаженный конец по дуге, N=2 удлиненный конец с учетом толщины.

setdash -- берет из стека одно число D и массив [...] и задает способ рисования линии пунктиром. В массиве может быть разное число элементов в зависимости от сложности пунктира. Проще всего это показать на примерах. Так [] 0 setdash -- это сплошная линия, [3] 0 setdash -- это простая пунктирная линия 3 pt чертим, 3pt не чертим и так далее. Для простоты я буду использовать английский язык, он короче - итак 3 on, 3 off, 3 on, 3 off, etc., [4 2] 0 setdash -- это более фасонная пунктирная линия: 4 on, 2 off, 4 on, 2 off, etc., [3 5] 6 setdash -- это пунктирная линия с начальной фазой. Тут алгоритм следующий. Линия сначала прокручивается вхолостую, пока не достигнет начальной фазы. И с нее начинается рисование. В данном примере начальная фаза 6, проходим 3 on вхолостую так как меньше начальной фазы, проходим 5 off, при этом движении начальная фаза пересекается после 3 off, значит реально будет начерчено 2 off, 3 on, 5 off, etc.. [2 3] 11 setdash -- попробуйте догадаться, что ответ будет таким 1 on, 3 off, 2 on, 3 off, etc..

stroke -- эта команда заканчивает траекторию и реально рисует линию с учетом всех параметров, определенных в других командах. Для прямоугольных контуров введен специальный оператор, для которого предварительного задания контура не требуется, так как параметры прямоугольника являются его аргументами. Он называется

rectstroke -- и он имеет четыре аргумента x, y, w, h, то есть координаты левого нижнего угла прямоугольника, ширина и высота. Естественно из стека он берет эти числа в обратном порядке. Вместо чисел можно задавать массив или строку, которые содержат эти числа. Причем в массиве и строке могут быть описаны не один, а несколько прямоугольников сразу. Есть даже и более сложная форма, в которой после четырех чисел задается матрица CTM (об этом можно будет прочитать позднее). Эта матрица умножается на текущую матрицу перед рисованием.

fill -- эта команда заливает внутреннюю область контура цветом или уровнем серого. Если контур не замкнут, она его замыкает, соединяя последнюю точку с первой. Очень часто приходится заливать цветом прямоугольные области. Для удобства записи введет оператор

rectfill -- для которого прямоугольный контур можно задавать непосредственно перед его использование в виде четырех чисел x, y, w, h, то есть координаты левого нижнего угла прямоугольника, ширину и высоту. Естественно из стека он берет эти числа в обратном порядке. Вместо чисел можно задавать массив или строку, которые содержат эти числа. 

* Изображение текста
findfont -- которая заставляет интерпретатор искать нужный файл, все фонты исходно имеют размер 1 pt. Соотвественно фонт нужно промасштабировать. Это делает команда

scalefont -- она берет из стека число N и масштабирует фонт на этот размер, после этого команда

setfont -- устанавливает данный фонт как текущий для рисования командой show. 

show -- эта команда берет из стека строку символов, объект в круглых скобках, и рисует ее левым нижним краем на позиции курсора. 
** Шрифты
/Palatino-Roman
/Palatino-Italic
/Palatino-Bold
/Palatino-BoldItalic

/Times-Roman
/Times-Italic
/Times-Bold
/Times-BoldItalic

/Helvetica
/Helvetica-Oblique
/Helvetica-Bold
/Helvetica-BoldOblique

/Helvetica-Narrow
/Helvetica-Narrow-Oblique
/Helvetica-Narrow-Bold
/Helvetica-Narrow-BoldOblique

/Symbol

/Courier
/Courier-Oblique
/Courier-Bold
/Courier-BoldOblique

/AvantGarde-Book
/AvantGarde-BookOblique
/AvantGarde-Demi
/AvantGarde-DemiOblique

/Bookman-Demi
/Bookman-DemiItalic
/Bookman-Light
/Bookman-LightItalic

/NewCenturySchlbk-Roman
/NewCenturySchlbk-Italic
/NewCenturySchlbk-Bold
/NewCenturySchlbk-BoldItalic

/ZapfDingbats
/ZapfChancery-MediumItalic
** 
dup -- помещает в стек копию последнего элемента

pop -- вынимает из стека последний элемент, но ничего с ним не делает

stringwidth -- берет из стека строку символов и вычисляет ее ширину, но возвращает в стек два числа как X,Y смещение точки из начало в конец текста, второе число ноль. 

ashow -- он берет из стека три объекта (text) Y X и рисует текст таким образом, что каждый следующий символ сдвигается по отношению к предыдущему на заданное смещение X,Y. Иногда это бывает полезно. Для особых случаев есть еще оператор

widthshow -- аргументами которого являются четыре объекта cx cy char (text). Так они должны быть записаны перед его использованием, из стека он их берет в обратном порядке. Он рисует (text), но специальным образом - каждый символ с размерами, которые получаются добавлением к размерам символа char приращений cx и cy по горизонтали и по вертикали. Символ char задается своим ASCII кодом. 

* Глобальные преобразования системы координат

translate -- берет из стека два числа Y,X и переносит начало координат в точку с координатами X,Y. Это означает, что к координатам всех точек всех объектов перед рисованием будет прибавлены вектор с координатами X,Y. Другая команда

scale -- берет из стека два числа Y,X и умножает все координаты всех точек для всех объектов на два числа, горизонтальные координаты - на X, вертикальные - на Y. Еще одна команда

rotate -- берет из стека одно число A - угол в градусах и производит вращение всех координат всех объектов на этот угол. 

gsave -- запоминает все параметры рисования, которые были установлены на момент применения этой команды, и

grestore -- восстанавливает параметры, которые были спасены предыдущей командой. 

* Операторы циклов и условные операторы

repeat -- он берет из стека два объекта: процедуру и число повторений, после этого он повторяет процедуру столько раз, какое значение имеет число.

for -- он берет из стека четыре объекта: процедуру, конечное значение параметра, шаг по параметру, начальное значение параметра. Число повторений в нем не фигурирует и равно разности конечного и начального значений, деленной на шаг плюс 1. 

forall -- он берет из стека два сложных объекта: процедуру и массив, и повторяет процедуру со всеми элементами массива как параметром, то есть число повторений равно числу элементов массива.

В Постскрипте условия  записываются как
eg -- (=, равно)
ne -- (!=, не равно)
gt -- (>, больше)
ge -- (>=, больше или равно)
lt -- (<, меньше)
le -- (<=, меньше или равно)
Ясно, что все эти условия проверяются над двумя объектами в стеке, то есть их надо записывать перед записью самих операций. Логические переменные, получаемые в результате проверки условий, можно объединять операциями not, or и xor.
