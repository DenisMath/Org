http://www.linux.org.ru/books/GNU/bison/bison_toc.html
[[file:My%20Documents/Downloads/compiler.pdf][file:~flex_bison.pdf]]
* 2. Принципы Bison

В этой главе вводятся многие основные понятия, без которых детальное описание Bison не будет иметь смысла. Если вы ещё не знаете, как использовать Bison или Yacc, мы предлагаем вам начать с внимательного чтения этой главы.
** 2.1 Языки и контекстно-свободные грамматики

Для того, чтобы Bison мог разобрать программу на каком-то языке, этот язык должен быть описан контекстно-свободной грамматикой. Это означает, что вы определяете одну или более синтаксических групп и задаёте правила их сборки из составных частей. Например, в языке C одна из групп называется `выражение'. Правило для составления выражения может выглядеть так: "Выражение может состоять из знака `минус' и другого выражения". Другое правило: "Выражением может быть целое число". Как вы может видеть, правила часто бывают рекурсивными, но должно быть по крайней мере одно правило, выводящее из рекурсии.

Наиболее распространённой формальной системой для представления таких правил в удобном для человека виде является форма Бэкуса-Наура (БНФ, Backus-Naur Form, BNF), которая была разработана для описания языка Algol 60. Любая грамматика, выраженная в форме Бэкуса-Наура является контекстно-свободной грамматикой. Bison принимает на вход, в сущности, особый вид БНФ, адаптированный для машинной обработки.

Bison может работать не со всеми контекстно-свободными грамматиками, а только с грамматиками класса LALR(1). Коротко, это означает, что должно быть возможно определить, как разобрать любую часть входа, заглядывая вперёд не более, чем на одну лексему. Строго говоря, это описание LR(1)-грамматики, класс LALR(1) имеет дополнительные ограничения, которые не так просто объяснить. Но в обычной практике редко встречаются LR(1)-грамматики, которые не являются LALR(1). См. раздел 6.7 Загадочные конфликты свёртка/свёртка, для получения большей информации.

В правилах формальной грамматики языка каждый вид синтаксических единиц или групп называется символом. Те из них, которые формируются группировкой меньших конструкций в соответствии с правилами грамматики, называются нетерминальными символами, а те, что не могут разбиты -- терминальными символами или типами лексем. Мы называем часть входного текста, соответствующую одному терминальному символу лексемой, а соответствующую нетерминальному символу -- группой.

Для примера терминальных и нетерминальных символов можно использовать язык C. Лексемами C являются идентификаторы, константы (числовые и строковые), и различные ключевые слова, знаки арифметических операций и пунктуации. Таким образом, терминальные символы грамматики C это: `идентификатор', `число', `строка' и по одному символу на каждое ключевое слово, знак операции или пунктуации: `if', 'return', `const', `static', `int', `char', `знак плюс', `открывающая скобка', `закрывающая скобка', `запятая' и многие другие (эти лексемы могут быть разбиты на литеры, но это уже вопрос составления словарей, а не грамматики).

Вот простая функция на языке C, разбитая на лексемы:

@ifnotinfo

int             /* ключевое слово `int' */
square (int x)  /* идентификатор, открывающая круглая скобка, */
                /* идентификатор, идентификатор, закрывающая  */
                /* круглая скобка */
{               /* открывающая фигурная скобка */
  return x * x; /* ключевое слово `return', идентификатор, звёздочка, */
                /* идентификатор, точка с запятой */
}               /* закрывающая фигурная скобка */

Синтаксические группы C это: выражение, оператор, объявление и определение функции. Они представлены в грамматике C нетерминальными символами `выражение', `оператор', `объявление' и `определение функции'. Полная грамматика, для того, чтобы выразить смысл этих четырёх, использует десятки дополнительных языковых конструкций, каждой из которых соответствует свой нетерминальный символ. Пример выше является определением функции, он содержит одно объявление и один оператор. В операторе каждое `x', так же, как и `x * x' являются выражениями.

Каждому нетерминальному символу должны быть сопоставлены правила грамматики, показывающие, как он собирается из более простых конструкций. Например, одним из операторов C является оператор return, это может быть описано правилом грамматики, неформально читающимся так:

    `Оператор' может состоять из ключевого слова `return', `выражения' и `точки с запятой'. 

Должно существовать множество других правил для `оператор', по одному на каждый вид оператора C.

Один нетерминальный символ должен быть отмечен как специальный, определяющий завершённое высказывание на языке. Он называется начальным символом. В компиляторе это означает полную программу на входе. В языке C эту роль играет нетерминальный символ `последовательность определений и объявлений'.

Например, `1 + 2' является правильным выражением C -- правильной частью программы на C -- но не является правильной целой программой на C. В контекстно-свободной грамматике C это следует из того, что `выражение' не является начальным символом.

Анализатор Bison читает на входе последовательность лексем и группирует их, используя правила грамматики. Если вход правилен, конечным результатом будет свёртка всей последовательности лексем в одну группу, которой соответствует начальный символ грамматики. Если мы используем грамматику C, весь входной текст в целом должен быть `последовательностью определений и объявлений'. Если это не так, анализатор сообщит о синтаксической ошибке.
** 2.2 От формальных правил к входному тексту Bison

Формальная грамматика -- это математическая конструкция. Чтобы определить язык для Bison, вы должны написать файл, описывающий грамматику в синтаксисе Bison -- файл грамматики Bison. См. раздел 4. Файлы грамматики Bison.

Нетерминальный символ формальной грамматики на входе Bison представляется идентификатором, таким же как идентификатор C. По соглашению их нужно записывать в нижнем регистре, например: expr, stmt или declaration.

Представление в Bison нетерминальных символов также называется типом лексем. Типы лексем также могут быть представлены идентификаторами в стиле C. По соглашению эти идентификаторы следует записывать в верхнем регистре, чтобы отличить их от нетерминалов, например, INTEGER, IDENTIFIER, IF, или RETURN. Терминальный символ, соответствующий конкретному ключевому слову языка следует называть так же, как это ключевое слово выглядит в верхнем регистре. Терминальный символ error зарезервирован для восстановления после ошибок. См. раздел 4.2 Символы, терминальные и нетерминальные.

Терминальный символ также может быть представлен как однолитерная константа, как однолитерная константа C. Вам стоит делать так всегда, когда лексема представляет собой просто одиночную литеру (скобку, знак плюс и т.д.) -- используйте ту же литеру в качестве терминального символа для этой лексемы.

Третий способ представления терминального символа -- представление строковой константой C из нескольких литер. См. раздел 4.2 Символы, терминальные и нетерминальные, для получения большей информации.

Правила грамматики также содержат выражение в синтаксисе Bison. Например, вот правило Bison для оператора C return. Точка с запятой в кавычках является однолитерной лексемой, представляющей часть синтаксиса оператора C, а отдельная точка с запятой и двоеточие являются знаками пунктуации Bison, используемыми во всех правилах.

stmt:   RETURN expr ';'
        ;

См. раздел 4.3 Синтаксис правил грамматики.
** 2.3 Семантические значения

Формальная грамматика выбирает лексемы только по их виду, например, если в правиле упоминается терминальный символ `целочисленная константа', это означает, что в этой позиции грамматически допустима любая целочисленная константа. Точное значение константы не имеет значения для разбора -- если `x+4' грамматически допустимо, то `x+1' или `x+3989' равно допустимы.

Но точное значение очень важно, чтобы после разбора определить, что означает входной текст. Компилятор, не могущий различить в программе константы 4, 1 и 3989, бесполезен! Поэтому каждая лексема в грамматике Bison характеризуется как типом лексемы, так и семантическим значением. См. раздел 4.5 Определение семантики языка.

Тип лексемы -- это терминальный символ, определённый в грамматике, такой как INTEGER, IDENTIFIER или ','. Он даёт всю информацию, необходимую для принятия решения, где допустимо появления лексемы и как группировать её с другими лексемами. Правила грамматик не знают о лексемах ничего, кроме их типов.

Семантическое значение несёт всю остальную информацию о смысле лексемы, такую как значение целого или имя идентификатора (такие лексемы как ',', просто знаки пунктуации, не нуждаются в каком-либо семантическом значении).

Например, входная лексема может классифицироваться как лексема типа INTEGER и иметь семантическое значение 4. Другая входная лексема может иметь тот же тип INTEGER, но значение 3989. Если правило грамматики говорит, что допустима лексема типа INTEGER, будет принята любая из этих двух лексем, потому что обе они имеют тип INTEGER. Когда анализатор принимает лексему, он отслеживает её семантическое значение.

Каждая группа, так же как и её нетерминальный символ, может иметь семантическое значение. Например, в калькуляторе выражение обычно имеет семантическое значение, представляющее собой число. В компиляторе языка программирования выражение обычно имеет семантическое значение в виде дерева, описывающего смысл выражения.
** 2.4 Семантические действия

Чтобы быть полезной, программа должна делать нечто большее, чем разбор входного текста -- она должны также создавать некий выход, основанный на входе. В грамматике Bison правило грамматики может содержать действие, состоящее из операторов C. Каждый раз, когда анализатор распознаёт текст, соответствующий правилу, выполняется его действие. См. раздел 4.5.3 Действия.

Чаще всего целью действия является вычисление семантического значения всей конструкции по семантическим значениям её частей. Предположим, например, что у нас есть правило, гласящее, что выражение может быть суммой двух выражений. Когда анализатор распознаёт такую сумму, каждое из подвыражений имеет семантическое значение, описывающее, как оно построено. Действию этого правила следует создать значение подобного вида для только что распознанного большего выражения.

Например, вот правило, говорящее, что выражение может быть суммой двух подвыражений:

expr: expr '+' expr   { $$ = $1 + $3; }
        ;

Действие сообщает, как получить семантическое значение выражения суммы из значений двух подвыражений.
** 2.5 Положения

Многие приложения, такие как интерпретаторы или компиляторы, должны генерировать подробные и информативные сообщения об ошибках. Для обеспечения этого должно быть возможно отслеживать позицию в тексте или положение каждой синтаксической конструкции. Bison предоставляет механизм работы с такими положениями.

Каждая лексема имеет семантическое значение. Аналогично, каждой лексеме сопоставлено положение, но тип положений одинаков для всех лексем и групп. Более того, создаваемый анализатор снабжён структурой данных для информации о положениях, задаваемой по умолчанию (см. раздел 4.6 Отслеживание положений, для получения дальнейшей информации).

Как и с семантическими значениями, в действиях можно получить доступ к положениям, используя специальный набор конструкций. В приведённом выше примере положение группы в целом -- @$, в то время как положения подвыражений -- @1 и @3.

Когда обнаруживается текст, соответствующий правилу, для вычисления семантического значения его левой части используется действие по умолчанию (см. раздел 4.5.3 Действия). Точно так же, для положений используется другое действие по умолчанию. Однако действия для положений в большинстве случаев достаточно, в том смысле, что обычно не нужно описывать формирование @$ для каждого правила. При вычислении нового положения для данной группы по умолчанию анализатор берёт начало первого символа и конец последнего.
** 2.6 Выходной текст Bison: файл анализатора

Когда вы запускаете Bison, вы подаёте ему на вход файл грамматики Bison. Выходным текстом является исходный текст на C, осуществляющий разбор языка, описываемого грамматикой. Этот файл называется анализатором Bison. Имейте в виду, что утилита Bison и анализатор Bison -- это две разные программы: утилита Bison -- это программа, создающая на выходе анализатор Bison, который затем становится частью вашей программы.

Задачей анализатора Bison является сборка лексем в группы в соответствии с правилами грамматики, например, объединение идентификаторов и знаков операций в выражения. По мере выполнения этой задачи анализатор выполняет действия, сопоставленные используемым правилам грамматики.

Лексемы поступают из функции, называемой лексическим анализатором, которую вы должны каким-либо образом предоставить (например, написав её на C). Анализатор Bison вызывает лексический анализатор каждый раз, когда ему нужна новая лексема. Он не знает, что находится "внутри" лексемы (хотя её семантическое значение может отражать это). Обычно лексический анализатор получает лексемы анализом литер текста, но Bison не зависит от этого. См. раздел 5.2 Функция лексического анализатора yylex.

Файл анализатора Bison -- это код на C, определяющий функции yyparse, реализующую грамматику. Эта функция не образует целую программу на C -- вы должны предоставить некоторые дополнительные функции. Одна из них -- лексический анализатор. Другая -- функция, вызываемая анализатором для сообщения об ошибке. Кроме того, выполнение программы на C должно начинаться с функции main: вы должны создать её и вызывать из неё yyparse, иначе анализатор никогда не заработает. См. раздел 5. Интерфейс анализатора на C.

Все имена переменных и функций в файле анализатора Bison, помимо определённых в написанных вами действиях и имён типов лексем, начинаются с `yy' или `YY'. Сюда входят интерфейсные функции, такие как функция лексического анализатора yylex, функция сообщения об ошибке yyerror и сама функция анализатора yyparse. Также это относится к многочисленным идентификаторам, используемым во внутренних целях. Поэтому вам следует избегать использования идентификаторов C, начинающихся с `yy' или `YY' в грамматике Bison, за исключением определённых в этом руководстве.

В некоторых случаях файл анализатора Bison включает системные заголовки, и тогда при написании вашего кода следует учитывать, что некоторые идентификаторы зарезервированы такими заголовками. На некоторых не-GNU системах включаются заголовки <alloca.h>, <stddef.h> и <stdlib.h>, поскольку это необходимо для объявления функций выделения памяти и связанных типов. Другие системные заголовки могут быть включены, если вы придадите ненулевое значение YYDEBUG (см. раздел 9. Отладка вашего анализатора).
** 2.7 Этапы использования Bison

Реальный процесс разработки языка с использованием Bison, от спецификации грамматики до работающего компилятора или интерпретатора, содержит следующие этапы:

    Формально описать грамматику в виде, распознаваемом Bison (см. раздел 4. Файлы грамматики Bison). Для каждого правила грамматики языка описать действия, которые должны выполняться при распознавании текста, соответствующего этому правилу. Действие описывается последовательностью операторов C.
    Написать лексический анализатор для обработки входного текста и передачи лексем анализатору. Лексический анализатор может быть написан вручную на C (см. раздел 5.2 Функция лексического анализатора yylex). Он также может быть создан с помощью Lex, но использование Lex в этом руководстве не обсуждается.
    Написать управляющую функцию, вызывающую анализатор, созданный Bison.
    Написать процедуру сообщения об ошибках. 

Чтобы превратить этот исходный код в работающую программу, вы должны выполнить следующие шаги:

    Обработайте описание грамматики Bison чтобы получить анализатор.
    Скомпилируйте код, созданный Bison, так же, как любой другой файл с исходным кодом.
    Соберите объектные файлы чтобы получить конечный продукт. 

** 2.8 Обзор схемы грамматики Bison

Входной файл утилиты Bison -- это файл грамматики Bison. Общий вид файла грамматики Bison следующий:

%{
Объявления C
%}

Объявления Bison

%%
Правила грамматики
%%
Дополнительный код на C

`%%', `%{' и `%}' -- это знаки пунктуации, присутствующие в любом файле грамматики Bison для разделения его секций.

Объявления C могут определять типы и переменные, используемые в действиях. Вы также можете использовать команды препроцессора для определения используемых там макросов и #include для включения файлов заголовков, делающих всё вышеперечисленное.

Объявления Bison задают имена терминальных и нетерминальных символов и могут также описывать приоритет операций и типы данных семантических значений различных символов.

Правила грамматики определяют, как каждый нетерминальный символ собирается из своих частей.

Дополнительный код на C может содержать любой код на C, который вы хотите использовать. Часто здесь находится определение лексического анализатора yylex и подпрограммы, вызываемые действиями правил грамматики. В простых программах здесь может находится и вся остальная часть программы. 

* 3. Примеры

Сейчас мы приведём и объясним три простые программы, написанные с использованием Bison: калькулятор обратной польской нотации, калькулятор алгебраической (инфиксной) нотации, и многофункциональный калькулятор. Все три протестированы под BSD Unix 4.3, каждая из них даёт пригодный для использования, хотя и ограниченный, интерактивный настольный калькулятор.

Эти примеры просты, но грамматики Bison для реальных языков программирования пишутся таким же образом.
** 3.1 Калькулятор обратной польской нотации

Первый пример -- это простой калькулятор с двойной точностью для выражений в обратной польской нотации (использующий постфиксные операции). Этот пример является хорошей отправной точкой, поскольку приоритеты операций не используются. Обработка приоритетов будет показана во втором примере.

Исходный код этого калькулятора называется `rpcalc.y'. По соглашению для входных файлов Bison используется расширение `.y'.
3.1.1 Объявления для rpcalc

Это объявления C и Bison для калькулятора обратной польской нотации. Как и в C, комментарии помещаются между `/*...*/'.

/* Калькулятор обратной польской нотации. */

%{
#define YYSTYPE double
#include <math.h>
%}

%token NUM

%% /* Далее следуют правила грамматики и действия */

Секция объявлений C (см. раздел 4.1.1 Секция объявлений C содержит две директивы препроцессора.

Директива #define определяет макрос YYSTYPE. Это задаёт тип данных C для семантических значений как лексем, так и групп (см. раздел 4.5.1 Типы данных семантических значений). Анализатор Bison будет использовать любой тип, заданный YYSTYPE, а если вы не определили его -- тип по умолчанию int. Поскольку мы указали double, с каждой лексемой и каждым выражением будет ассоциировано вещественное число.

Директива #include используется для объявления функции возведения в степень pow.

Из второй секции, объявлений Bison, Bison получает информацию о типах лексем (см. раздел 4.1.2 Секция объявлений Bison). Здесь должен быть объявлен любой терминальный символ, не являющийся однолитерной константой (они, как правило, не нуждаются в объявлении). В этом примере все арифметические операции обозначаются однолитерными константами, поэтому нужно объявить только терминальный символ NUM, тип лексемы для числовых констант.
3.1.2 Правила грамматики для rpcalc

Это правила грамматики для калькулятора обратной польской нотации.

input:    /* пусто */
        | input line
;

line:     '\n'
        | exp '\n'  { printf ("\t%.10g\n", $1); }
;

exp:      NUM             { $$ = $1;         }
        | exp exp '+'     { $$ = $1 + $2;    }
        | exp exp '-'     { $$ = $1 - $2;    }
        | exp exp '*'     { $$ = $1 * $2;    }
        | exp exp '/'     { $$ = $1 / $2;    }
      /* возведение в степень */
        | exp exp '^'     { $$ = pow ($1, $2); }
      /* унарный минус        */
        | exp 'n'         { $$ = -$1;        }
;
%%

Здесь определены группы "языка" rpcalc: выражение (названное exp), строка ввода (line), и законченный входной текст (input). У каждого из этих нетерминальных символов имеется несколько альтернативных правил, объединённых знаком `|', читающимся "или". В последующих разделах объясняется, что означают эти правила.

Семантика языка определяется действиями, предпринимаемыми при распознавании группы. Действия -- это код на C, находящийся между фигурными скобками. См. раздел 4.5.3 Действия.

Вы должны писать эти действия на C, однако Bison предоставляет способ передачи семантических значений между правилами. В каждом действии псевдопеременная $$ обозначает семантическое значение группы, которую собирает это правило. Присвоение $$ значения -- основная работа большинства действий. На семантические значения компонентов правила можно ссылаться как на $1, $2 и т.д.
3.1.2.1 Объяснение input

Рассмотрим определение input:

input:    /* пусто */
        | input line
;

Это определение читается следующим образом: "Законченный входной текст представляет собой пустую строку либо законченный входной текст, за которым следует входная строка". Обратите внимание, что "законченный входной текст" определяется в терминах самого себя. Это определение называется леворекурсивным, поскольку input всегда является самым левым символом последовательности. См. раздел 4.4 Рекурсивные правила.

Первая альтернатива пуста, поскольку между двоеточием и первым знаком `|' нет символов. Это означает, что input может соответствовать пустой входной строке (без лексем). Мы пишем так правило, потому что допустимо нажатие клавиш Ctrl-d сразу после запуска калькулятора. По соглашению пустая альтернатива ставится первой и в ней пишется комментарий `/* пусто */'.

Второе альтернативное правило (input line) описывает любой нетривиальный входной текст. Оно означет "После прочтения любого количества строк, прочитать ещё одну, если это возможно". Левая рекурсия заставляет это правило выполняться в цикле. Поскольку первая альтернатива соответствует пустому входному тексту, цикл будет выполняться ноль или более раз.

Функция анализатора yyparse продолжает обработку входного текста до тех пор, пока не будет обнаружена грамматическая ошибка или лексические анализатор не скажет, что входных лексем больше нет -- мы условимся, что это произойдёт по достижении конца файла.
3.1.2.2 Объяснение line

Теперь рассмотрим определение line:

line:     '\n'
        | exp '\n'  { printf ("\t%.10g\n", $1); }
;

Первая альтернатива -- это лексема литеры новой строки, это означает, что rpcalc принимает пустую строку (и игнорирует её, поскольку там нет никакого правила). Вторая альтернатива -- это выражение, за которым следует литера новой строки. Именно эта альтернатива несёт основную пользу rpcalc. Семантическое значение группы exp -- это значение $1, потому что искомое exp -- первый символ альтернативы. Действие выводит это значение, которое является результатом вычислений, заданных пользователем.

Это действие необычно, потому что оно не присваивает значения $$. Вследствие этого семантическое значение line не инициализируется (значение будет непредсказуемым). Было бы ошибкой в программе, если бы это значение когда-либо использовалось, но мы не пользуемся им -- после того, как rpcalc вывел значение введённой пользователем входной строки, оно больше не нужно.
3.1.2.3 Объяснение expr

Группа exp имеет несколько правил, по одному на каждый вид выражений. Первое правило обрабатывает наиболее простым выражениям -- отдельным числам. Второе обрабатывает выражение сложения, которые выглядит как два выражения, за которыми следует знак `плюс'. Третье обрабатывает вычитание и т.д.

exp:      NUM
        | exp exp '+'     { $$ = $1 + $2;    }
        | exp exp '-'     { $$ = $1 - $2;    }
        ...
        ;

Мы используем `|' чтобы объединить все правила для exp, но мы могли бы с тем же успехом написать их отдельно:

exp:      NUM ;
exp:      exp exp '+'     { $$ = $1 + $2;    } ;
exp:      exp exp '-'     { $$ = $1 - $2;    } ;
        ...

У большей части правил есть действия, вычисляющие значение выражения из значений его частей. Например, в правиле для сложения $1 относится к первому компоненту exp, а $2 -- ко второму. Третий компонент, '+' не имеет осмысленного ассоциированного семантического значения, но если бы он имел его, на него можно было ссылаться как на $3. Когда yyparse, используя это правило, распознаёт выражение-сумму, сумма значений двух подвыражений даст значение всего выражения. См. раздел 4.5.3 Действия.

Вы не обязаны приписывать действие каждому правилу. Когда у правила нет действия, по умолчанию Bison копирует значение $1 в $$. Именно это происходит в первом правиле (используюшем NUM).

Показанный здесь способ форматирования -- рекомендуемое соглашение, но Bison не требует этого. Вы можете добавлять или изменять промежутки по своему усмотрению. Например, такая запись:

exp   : NUM | exp exp '+' {$$ = $1 + $2; } | ...

означает то же, что и:

exp:      NUM
        | exp exp '+'    { $$ = $1 + $2; }
        | ...

Однако последняя намного более наглядна.
3.1.3 Лексический анализатор rpcalc

Задачей лексического анализатора является низкоуровневый разбор -- преобразование литер или последовательностей литер входного текста в лексемы. Анализатор Bison получает эти лексемы, вызывая лексический анализатор. См. раздел 5.2 Функция лексического анализатора yylex.

Для работы калькулятора обратной польской нотации нужен весьма простой лексический анализатор. Он пропускает пробелы и знаки табуляции, читает числа как значения типа double и возвращает их как лексемы типа NUM. Любые другие литеры, не являющиеся частью числа, считаются отдельными лексемами. Имейте в виду, что код лексемы для таких однолитерных лексем -- это сама литера.

Возвращаемое значение функции лексического анализатора -- это числовой код, представляющий тип лексемы. Текст, используемый в правилах Bison для обозначения типа лексемы, также является выражением C для числового кода этого типа. Это может работать двумя способами. Если тип лексемы является литерой, её числовым кодом будет ASCII-код этой литеры, вы можете использовать в лексическом анализаторе в качестве числа ту же литеру. Если тип лексемы -- идентификатор, этот идентификатор Bison определяет как макрос C, определением которого будет подходящее число. В этом примере, поэтому, NUM становится макросом, используемым yylex.

Семантическое значение лексемы (если оно у неё есть) сохраняется в глобальной переменной yylval, где её и ищет анализатор Bison (тип данных yylval -- YYSTYPE, определяемый в начале грамматики; см. раздел 3.1.1 Объявления для rpcalc).

Нулевой код типа лексемы возвращается, если обнаружен конец файла (Bison считает указателем конца входного файла любые неположительные значения).

Ниже приведён код лексического анализатора:

/* Лексический анализатор возвращает вещественное число
   с двойной точностью в стеке и лексему NUM, или прочитанную
   литеру ASCII, если это не число. Все пробелы и знаки
   табуляции пропускаются, в случае конца файла возвращается 0. */

#include <ctype.h>

int
yylex (void)
{
  int c;

  /* пропустить промежутки  */
  while ((c = getchar ()) == ' ' || c == '\t')
    ;
  /* обработка чисел       */
  if (c == '.' || isdigit (c))
    {
      ungetc (c, stdin);
      scanf ("%lf", &yylval);
      return NUM;
    }
  /* вернуть конец файла  */
  if (c == EOF)
    return 0;
  /* вернуть одну литеру */
  return c;
}

3.1.4 Управляющая функция

В соответствии c духом этого примера управляющая функция сведена к явному минимуму. Единственное требование -- она должна вызывать yyparse чтобы запустить процесс разбора.

int
main (void)
{
  return yyparse ();
}

3.1.5 Подпрограмма сообщения об ошибках

Когда yyparse обнаруживает синтаксическую ошибку, она вызывает функцию сообщения об ошибках yyerror для вывода сообщения об ошибке (обычно, но не всегда, "ошибка разбора"). Предоставить эту функцию должен программист (см. раздел 5. Интерфейс анализатора на C), поэтому приведём используемое нами определение:

#include <stdio.h>

void
yyerror (const char *s)  /* вызывается yyparse в случае ошибки */
{
  printf ("%s\n", s);
}

После возврата из функции yyerror анализатор Bison може произвести восстановление после ошибки и продолжить разбор, если грамматика содержит подходящее правило ошибки (см. раздел 7. Восстановление после ошибок). В противном случае yyparse вернёт ненулевое значение. В этом примере мы не писали никаких правил ошибки, поэтому любой неправильный входной текст приведёт к завершению работы калькулятора. Это поведение неудачно для настоящего калькулятора, но вполне подходит для первого примера.
3.1.6 Запуск Bison для создания анализатора

Перед запуском Bison для создания анализатора нам нужно решить, хранить весь исходный код в одном или нескольких файлах. Для такого простого примера проще всего будет поместить всё в один файл. Определение yylex, yyerror и main находятся в конце файла, в секции "дополнительного кода на C" (см. раздел 2.8 Обзор схемы грамматики Bison).

В больших проектах, скорее всего, у вас будет несколько файлов с исходным кодом, и вы будет использовать make для их перекомпиляции.

Если весь исходный код находится в одном файле, используйте следующую команду для преобразования его в файл анализатора:

bison имя_файла.y

В этом примере файл называется `rpcalc.y' ("Reverse Polish CALCulator" -- калькулятор обратной польской нотации). Bison создаёт файл `имя_файла.tab.c', убирая `.y' из названия исходного файла. Выходной файл Bison содержит исходный код yyparse. Дополнительные функции (yylex, yyerror и main) в точности копируются из входного файла в выходной.
3.1.7 Компиляция файла анализатора

Так нужно компилировать и запускать файл анализатора:

# Перечислить файлы в текущем каталоге.
$ ls
rpcalc.tab.c  rpcalc.y

# Компиляция анализатора Bison.
# `-lm' указывает компилятору искать pow в
# математической библиотеке.
$ cc rpcalc.tab.c -lm -o rpcalc

# Снова перечислить файлы.
$ ls
rpcalc  rpcalc.tab.c  rpcalc.y

Файл `rpcalc' теперь содержит исполняемый код. Вот пример сеанса работы с rpcalc.

$ rpcalc
4 9 +
13
3 7 + 3 4 5 *+-
-13
3 7 + 3 4 5 * + - n              Обратите внимание на унарный минус
                                       `n'
13
5 6 / 4 n +
-3.166666667
3 4 ^                            Возведение в степень
81
^D                               Признак конца файла
$

** 3.2 Калькулятор инфиксной нотации: calc

Теперь мы модифицируем rpcalc для обработки инфиксных, а не постфиксных операций. Инфиксная нотация предполагает принцип приоритета операций и необходимость обработки скобок произвольной глубины вложенности. Вот код Bison файла `calc.y' -- инфиксного настольного калькулятора.

/* Калькулятор для выражени в инфиксной нотации -- calc */

%{
#define YYSTYPE double
#include <math.h>
%}

/* Объявления BISON */
%token NUM
%left '-' '+'
%left '*' '/'
%left NEG     /* обращение -- унарный минус */
%right '^'    /* возведение в степень       */

/* Далее следует грамматика */
%%
input:    /* пустая строка */
        | input line
;

line:     '\n'
        | exp '\n'  { printf ("\t%.10g\n", $1); }
;

exp:      NUM                { $$ = $1;         }
        | exp '+' exp        { $$ = $1 + $3;    }
        | exp '-' exp        { $$ = $1 - $3;    }
        | exp '*' exp        { $$ = $1 * $3;    }
        | exp '/' exp        { $$ = $1 / $3;    }
        | '-' exp  %prec NEG { $$ = -$2;        }
        | exp '^' exp        { $$ = pow ($1, $3); }
        | '(' exp ')'        { $$ = $2;         }
;
%%

Функции yylex, yyerror и main могут быь теми же, что и раньше.

В этом коде показаны две новые важные возможности.

Во второй секции (объявления Bison) %left объявляет типы лексем и говорит, что они обозначают левоассоциативные операции. Объявления %left и %right (правая ассоциативность) используются вместо %token, использующегося для объявления имени типа лексемы без ассоциативности (эти лексемы являются однолитерными константами, которые обычно не требуют объявления. Мы объявляем их здесь для указания ассоциативности).

Приоритет операций определяется порядком строк с объявлениями -- чем больше номер строки (чем ниже она на странице или на экране), тем выше приоритет. Отсюда, возведение в степень имеет наивысший приоритет, далее идут унарный минус (NEG), `*' и `/' и т.д. См. раздел 6.3 Приоритет операций.

Другая новая возможность -- %prec в секции грамматики для операции унарного минуса. %prec просто указывает Bison, что правило `| '-' exp' имеет тот же приоритет, что и NEG -- в данном случае следующий за наивысшим. См. раздел 6.4 Контекстно-зависимый приоритет.

Вот пример работы с `calc.y':

$ calc
4 + 4.5 - (34/(8*3+-3))
6.880952381
-56 + 2
-54
3 ^ 2
9

** 3.3 Простое восстановление после ошибок

До сих пор это руководство не касалось вопроса восстановления после ошибок -- как продолжить разбор после того, как анализатор обнаружил синтаксическую ошибку. Всё, что мы предпринимали -- это выдача сообщения об ошибке функцией yyerror. Вспомним, что по умолчанию после вызова yyerror yyparse завершает работу. Это значит, что неправильный ввод приведёт к завершению работы калькулятора. Сейчас мы покажем, как исправить этот недостаток.

Язык Bison содержит зарезервированное слово error, которое можно включить в правило грамматики. В следующем примере оно добавлено к одной из альтернатив line:

line:     '\n'
        | exp '\n'   { printf ("\t%.10g\n", $1); }
        | error '\n' { yyerrok;                  }
;

Это добавление к грамматике допускает простое восстановление после ошибок в случае ошибки разбора. Если читается выражение, которое не может быть вычислено, третьим правилом для line будет распознана ошибка, и разбор продолжится (однако функция yyerror по-прежнему используется для вывода сообщения). Действие выполняет оператор yyerrok, автоматически определяемый Bison макрос. Он означает, что восстановление после ошибки завершено (см. раздел 7. Восстановление после ошибок). Обратите внимания на различие между yyerrok и yyerror -- ни то, ни другое не опечатка.

Этот вид восстановления после ошибок работает с синтаксическими ошибками. Есть другие виды ошибок, например, деление на ноль, вызывающее сигнал исключения, обычно являющегося фатальным. Настоящая программа калькулятора должна обрабатывать этот сигнал и использовать longjmp для возврата в функцию main и продолжения разбора входных строк. Ей следует также отбросить остаток текущей строки входа. Мы не будем далее обсуждать этот вопрос, потому что он не характерен для программ Bison.
** 3.4 Калькулятор с отслеживаием положений: ltcalc

Этот пример расширяет калькулятор инфиксной нотации отслеживанием положений. Это свойство будет использоваться для улучшения сообщений об ошибках. Для большей ясности этот пример -- простой целочисленный калькулятор, поскольку большая часть изменений, необходимых для использования положений, будет сделана в лексическом анализаторе.
3.4.1 Объявления ltcalc

Объявления C и Bison для калькулятора с отслеживанием положение те же самые, что и для калькулятора инфиксной нотации.

/* Калькулятор с отслеживанием положений.  */

%{
#define YYSTYPE int
#include <math.h>
%}

/* Объявления Bison.  */
%token NUM

%left '-' '+'
%left '*' '/'
%left NEG
%right '^'

%% /* Далее следует грамматика */

Заметьте, что специальных объявлений для работы с положениями нет. Определять тип данных для сохранения положений не нужно, мы будем использовать тип, заданный по умолчанию (см. раздел 4.6.1 Тип данных положений), являющийся структурой с четырьмя следующими целочисленными полями: first_line, first_column, last_line и last_column.
3.4.2 Правила грамматики ltcalc

Обрабатываются положения или нет, не влияет на синтаксис вашего языка. Поэтому правила грамматики языка в этом примере будут очень похожи на правила в предыдущем примере, мы только модифицируем их для работы с новой информацией.

В этом примере мы будем использовать положения для сообщения о делении на ноль, и определения места неправильных выражений и подвыражений.

input   : /* пусто */
        | input line
;

line    : '\n'
        | exp '\n' { printf ("%d\n", $1); }
;

exp     : NUM           { $$ = $1; }
        | exp '+' exp   { $$ = $1 + $3; }
        | exp '-' exp   { $$ = $1 - $3; }
        | exp '*' exp   { $$ = $1 * $3; }
        | exp '/' exp
            {
              if ($3)
                $$ = $1 / $3;
              else
                {
                  $$ = 1;
                  fprintf (stderr, "%d.%d-%d.%d: деление на ноль",
                           @3.first_line, @3.first_column,
                           @3.last_line, @3.last_column);
                }
            }
        | '-' exp %preс NEG     { $$ = -$2; }
        | exp '^' exp           { $$ = pow ($1, $3); }
        | '(' exp ')'           { $$ = $2; }

Этот код показывает, как получать значения положений изнутри семантических действий, используя псевдопеременные @n для компонентов правила и @$ -- для групп.

Нам не нужно присваивать значение @$, создаваемый анализатор делает это автоматически. По умолчанию перед выполнением кода на C для каждого действия @$ правила с n компонентами сопоставляется интервал от начала @1 до конца @n. Это поведение может быть переопределено (см. раздел 4.6.3 Действие по умолчанию для положений), а для очень специфических правил @$ может вычисляться вручную.
3.4.3 Лексический анализатор ltcalc.

До сих пор для отслеживания положений мы полагались на значения Bison по умолчанию. Следующим шагом мы перепишем лексический анализатор и сделаем его способным передавать в анализатор положения лексем, как он уже делает это с их семантическими значениями.

Для этой цели мы должны принимать в расчёт каждую литеру входного текста, чтобы избежать того, что вычисленные положения будут неверными.

int
yylex (void)
{
  int c;

  /* пропустить промежутки */
  while ((c = getchar ()) == ' ' || c == '\t')
    ++yylloc.last_column;

  /* шаг */
  yylloc.first_line = yylloc.last_line;
  yylloc.first_column = yylloc.last_column;

  /* обработка чисел */
  if (isdigit (c))
    {
      yylval = c - '0';
      ++yylloc.last_column;
      while (isdigit (c = getchar ()))
        {
          ++yylloc.last_column;
          yylval = yylval * 10 + c - '0';
        }
      ungetc (c, stdin);
      return NUM;
    }

  /* вернуть конец файла */
  if (c == EOF)
    return 0;

  /* вернуть однц литеру и обновить положение */
  if (c == '\n')
    {
      ++yylloc.last_line;
      yylloc.last_column = 0;
    }
  else
    ++yylloc.last_column;
  return c;
}

В основном, лексический анализатор делает то же, что и раньше: пропускает пробелы и знаки табуляции и читает числа или однолитерные лексемы. Дополнительно он обновляет yylloc, глобальную переменную (типа YYLTYPE), содержащую положение лексемы.

Теперь, каждый раз, когда функция возвращет лексему, в распоряжении анализатора находятся как её номер, так и семантическое значение и положение в тексте. Последнее необходимое изменение -- инициализация yylloc, например, в управляющей функции.

int
main (void)
{
  yylloc.first_line = yylloc.last_line = 1;
  yylloc.first_column = yylloc.last_column = 0;
  return yyparse ();
}

Помните, что вычисление положений не касается синтаксиса. Каждая литера должна быть ассоциирована с обновлением информации о положении, независимо от того, находится ли она в правильном входном тексте, в комментариях, в строковой константе и т.д.
** 3.5 Многофункциональный калькулятор: mfcalc

Теперь, когда мы уже обсудили основы Bison, пришло время перейти к более сложной задаче. Приведённые выше калькуляторы поддерживали только пять функций: `+', `-', `*', `/' и `^'. Было бы приятно иметь калькулятор, предоставляющий другие математические функции, такие как sin, cos и т.д.

Добавить новые операции в инфиксный калькулятор, до тех пор, пока они обозначаются односимвольными константами, несложно. Лексический анализатор yylex возвращает все нечисловые литеры как лексемы, так что для добавления операции достаточно введения нового правила грамматики. Но мы хотим иметь нечто более гибкое, встроенные функции, синтаксис которых выглядит так:

имя_функции (аргумент)

В то же время, мы добавим в калькулятор память, допуская создание именованных переменных, сохранение в них значений и последующее использование. Вот пример сеанса работы многофункционального калькулятора:

$ mfcalc
pi = 3.141592653589
3.1415926536
sin(pi)
0.0000000000
alpha = beta1 = 2.3
2.3000000000
alpha
2.3000000000
ln(alpha)
0.8329091229
exp(ln(beta1))
2.3000000000
$

Обратите внимание, что допускаются множественное присваивание и вложенные вызовы функций.
3.5.1 Объявления mfcalc

Вот объявления C и Bison для многофункционального калькулятора.

%{
#include <math.h>  /* Математические функции: cos(), sin() и т.д. */
#include "calc.h"  /* Содержит определение `symrec'               */
%}
%union {
double     val;  /* Чтобы возвращать числа.                     */
symrec  *tptr;   /* Чтобы возвращать указатели таблицы символов */
}

%token <val>  NUM        /* Простое число двойной точности   */
%token <tptr> VAR FNCT   /* Переменная и функция             */
%type  <val>  exp

%right '='
%left '-' '+'
%left '*' '/'
%left NEG     /* Обращение -- унарный минус */
%right '^'    /* Возведение в степень       */

/* Далее следует грамматика */

%%

Вышеприведённая грамматика вводит только две новые возможности языка Bison. Эти возможности позволяют семантическим значениям иметь различные типы данных (см. раздел 4.5.2 Несколько типов значений).

Объявление %union задаёт весь список возможных типов, это употребляется вместо определения YYSTYPE. Допустимые типы теперь: вещественные числа двойной точности (для exp и NUM) и указатели на элементы таблицы символов. См. раздел 4.7.3 Набор типов значений.

Поскольку значения теперь могут иметь различные типы, необходимо ассоциировать тип с каждым символом грамматики, семантическое значение которого используется. Эти символы: NUM, VAR, FNCT и exp. Их объявления дополнены информацией об их типах данных (помещённой в угловых скобках).

Конструкция Bison %type используется для объявления нетерминальных символов, так же как %token используется для объявления типов лексем. Ранее мы не использовали %type, потому что нетерминальные символы обычно неявно объявляются правилами, определяющими их. Но exp должно быть объявлено явно чтобы можно было задать тип его значения. См. раздел 4.7.4 Нетерминальные символы.
3.5.2 Правила грамматики mfcalc

Вот правила грамматики многофункционального калькутора. Большая их часть напрямую скопирована из calc. Введено три новых правила, использующие VAR и FNCT.

input:   /* пусто */
        | input line
;

line:
          '\n'
        | exp '\n'   { printf ("\t%.10g\n", $1); }
        | error '\n' { yyerrok;                  }
;

exp:      NUM                { $$ = $1;                         }
        | VAR                { $$ = $1->value.var;              }
        | VAR '=' exp        { $$ = $3; $1->value.var = $3;     }
        | FNCT '(' exp ')'   { $$ = (*($1->value.fnctptr))($3); }
        | exp '+' exp        { $$ = $1 + $3;                    }
        | exp '-' exp        { $$ = $1 - $3;                    }
        | exp '*' exp        { $$ = $1 * $3;                    }
        | exp '/' exp        { $$ = $1 / $3;                    }
        | '-' exp  %prec NEG { $$ = -$2;                        }
        | exp '^' exp        { $$ = pow ($1, $3);               }
        | '(' exp ')'        { $$ = $2;                         }
;
/* End of grammar */
%%

3.5.3 Таблица символов mfcalc

Многофункциональному калькулятору требуется таблица символов для отслеживания имён и значений переменных и функций. Это не влияет на правила грамматики (за исключением действий) или объявления Bison, но требует введения некоторых дополнительных функций на C.

Сама таблица символов состоит из связанного списка записей. Её определение, находящееся в заголовке `calc.h', приведено далее. Оно позволяет размещать в таблице как функции, так и переменные.

/* Тип функций.                                      */
typedef double (*func_t) (double);

/* Тип данных для связей в цепочке символов.         */
struct symrec
{
  char *name;  /* имя символа                        */
  int type;    /* тип символа: либо VAR, либо FNCT   */
  union
  {
    double var;                  /* значение VAR     */
    func_t fnctptr;              /* значение FNCT    */
  } value;
  struct symrec *next;    /* поле связи              */
};

typedef struct symrec symrec;

/* Таблица символов: цепочка `struct symrec'.        */
extern symrec *sym_table;

symrec *putsym (const char *, func_t);
symrec *getsym (const char *);

Новая версия main включает вызов init_table, функции, инициализирующей таблицу символов. Вот текст этих двух функций

#include <stdio.h>

int
main (void)
{
  init_table ();
  return yyparse ();
}

void
yyerror (const char *s)  /* Вызывается yyparse в случае ошибки */
{
  printf ("%s\n", s);
}

struct init
{
  char *fname;
  double (*fnct)(double);
};

struct init arith_fncts[] =
{
  "sin",  sin,
  "cos",  cos,
  "atan", atan,
  "ln",   log,
  "exp",  exp,
  "sqrt", sqrt,
  0, 0
};

/* Таблица символов: цепочка `struct symrec'.  */
symrec *sym_table = (symrec *) 0;

/* Поместить арифметические функции в таблицу. */
void
init_table (void)
{
  int i;
  symrec *ptr;
  for (i = 0; arith_fncts[i].fname != 0; i++)
    {
      ptr = putsym (arith_fncts[i].fname, FNCT);
      ptr->value.fnctptr = arith_fncts[i].fnct;
    }
}

Вы можете добавить к калькулятору дополнительные функции, просто редактируя список инициализации и включая необходимые файлы заголовков.

Две важные функции позволяют просматривать символы в таблице и вводить новые. Функции putsym передаётся имя и тип (VAR или FNCT) заносимого объекта. Объект включается в начало списка, и возвращается указатель на объект. Функции getsym передаётся имя искомого символа. Если он найден, возвращается указатель на него, иначе же ноль.

symrec *
putsym (char *sym_name, int sym_type)
{
  symrec *ptr;
  ptr = (symrec *) malloc (sizeof (symrec));
  ptr->name = (char *) malloc (strlen (sym_name) + 1);
  strcpy (ptr->name,sym_name);
  ptr->type = sym_type;
  ptr->value.var = 0; /* set value to 0 even if fctn.  */
  ptr->next = (struct symrec *)sym_table;
  sym_table = ptr;
  return ptr;
}

symrec *
getsym (const char *sym_name)
{
  symrec *ptr;
  for (ptr = sym_table; ptr != (symrec *) 0;
       ptr = (symrec *)ptr->next)
    if (strcmp (ptr->name,sym_name) == 0)
      return ptr;
  return 0;
}

Функция yylex теперь должна распознавать переменные, числовые значения и односимвольные арифметические операции. Строки алфавитноцифровых литер, начинающиеся не с цифры, распознаются или как переменные, или как функции, в зависимости от того, что говорится о них в таблице символов.

Строка передаётся функции getsym для поиска в таблице символов. Если имя встречается в таблице, в yyparse возвращаются указатель на его положение и его тип (VAR или FNCT). Если в таблице его ещё нет, оно заносится как VAR, используя putsym. Опять же, указатель и тип (который должен быть VAR) возвращаются в yyparse.

Для обработки числовых значений и арифметических операций изменения в yylex не нужны.

#include <ctype.h>

int
yylex (void)
{
  int c;

  /* Игнорировать промежутки, получить первый непробельный символ.  */
  while ((c = getchar ()) == ' ' || c == '\t');

  if (c == EOF)
    return 0;

  /* С литеры начинается число => разобрать число.                  */
  if (c == '.' || isdigit (c))
    {
      ungetc (c, stdin);
      scanf ("%lf", &yylval.val);
      return NUM;
    }

  /* С литеры начинается идентификатор => читать имя.              */
  if (isalpha (c))
    {
      symrec *s;
      static char *symbuf = 0;
      static int length = 0;
      int i;

      /* Первоначально сделать буфер достаточно большим
         для имени символа из 40 литер.  */
      if (length == 0)
        length = 40, symbuf = (char *)malloc (length + 1);

      i = 0;
      do
        {
          /* Если буфер полон, расширить его.          */
          if (i == length)
            {
              length *= 2;
              symbuf = (char *)realloc (symbuf, length + 1);
            }
          /* Добавить эту литеру в буфер.              */
          symbuf[i++] = c;
          /* Получить следующую литеру.                */
          c = getchar ();
        }
      while (c != EOF && isalnum (c));

      ungetc (c, stdin);
      symbuf[i] = '\0';

      s = getsym (symbuf);
      if (s == 0)
        s = putsym (symbuf, VAR);
      yylval.tptr = s;
      return s->type;
    }

  /* Любая другая литера сама по себе является лексемой.        */
  return c;
}

Эта программа одновременно и достаточно мощна, и гибка. Вы можете легко добавлять новые функции и также несложно модифицировать код для введения предопределённых переменных, таких как pi и e.
** 3.6 Упражнения

    Добавьте несколько новых функций из `math.h' в список инициализации.
    Добавьте ещё один массив, содержащий константы и их значения. Потом модифицируйте init_table чтобы внести эти константы в таблицу символов. Проще всего будет придать константам тип VAR.
    Заставьте программу выводить сообщение об ошибке, если пользователь ссылается на неинициализированную переменную каким-либо образом, кроме присвоения ей значения. 


