* 1. Лекция: Начальные сведения о языке
	
История создания языка и его эволюция. Международный стандарт языка. Сферы применения языка Си++. Пример простой программы. Объясняется процесс ее написания, использования простейших конструкций языка, использования транслятора и запуск программы на выполнение.
Содержание

    История и назначение языка Си++
    Простейшая программа на языке Си++
    Компиляция и выполнение программы
    Компилирование и выполнение программ в среде Windows
    Компилирование и выполнение программ в среде Unix

** История и назначение языка Си++

Разработчиком языка Си++ является Бьерн Страуструп. В своей работе он опирался на опыт создателей языков Симула, Модула 2, абстрактных типов данных. Основные работы велись в исследовательском центре компании Bell Labs.

Непосредственный предшественник Си++ – язык Си с классами – появился в 1979 году, а в 1997 году был принят международный стандарт Си++, который фактически подвел итоги его 20-летнего развития. Принятие стандарта обеспечило единообразие всех реализаций языка Си++. Не менее важным результатом стандартизации стало то, что в процессе выработки и утверждения стандарта язык был уточнен и дополнен рядом существенных возможностей.

На сегодня стандарт утвержден Международной организацией по стандартизации ISO. Его номер ISO/IEC 14882. ISO бесплатно стандарты не распространяет. Его можно получить на узле американского национального комитета по стандартам в информационных технологиях: www.ncits.org

В России следует обращаться в ВНИИ Сертификации:

http://www.vniis.ru

Проекты стандарта имеются в свободном доступе:

ftp://ftp.research.att.com/dist/c++std/WP/CD2/

http://www.research.att.com/~bs/bs_faq.html

Язык Си++ является универсальным языком программирования, в дополнение к которому разработан набор разнообразных библиотек. Поэтому, строго говоря, он позволяет решить практически любую задачу программирования. Тем не менее, в силу разных причин (не всегда технических) для каких-то типов задач он употребляется чаще, а для каких-то – реже.

Си++ как преемник языка Си широко используется в системном программировании. На нем можно писать высокоэффективные программы, в том числе операционные системы, драйверы и т.п. Язык Си++ – один из основных языков разработки трансляторов.

Поскольку системное программное обеспечение часто бывает написано на языке Си или Си++, то и программные интерфейсы к подсистемам ОС тоже часто пишут на Си++.

Распределенные системы, функционирующие на разных компьютерах, также разрабатываются на языке Си++. Этому способствует то, что у широко распространенных компонентных моделей CORBA и COM есть удобные интерфейсы на языке Си++.

Обработка сложных структур данных – текста, бизнес-информации, Internet-страниц и т.п. – одна из наиболее распространенных возможностей применения языка. В прикладном программировании, наверное, проще назвать те области, где язык Си++ применяется мало.

Разработка графического пользовательского интерфейса на языке Си++ выполняется, в основном, тогда, когда необходимо разрабатывать сложные, нестандартные интерфейсы. Простые программы чаще пишутся на языках Visual Basic, Java и т.п.

Программирование для Internet в основном производится на языках Java, VBScript, Perl.

В целом надо сказать, что язык Си++ в настоящее время является одним из наиболее распространенных языков программирования в мире.
** Простейшая программа на языке Си++

Самая короткая программа на языке Си++ выглядит так:

// Простейшая программа
int main() { return 1; }

Первая строчка в программе – комментарий, который служит лишь для пояснения. Признаком комментария являются два знака деления подряд ( // ).

main – это имя главной функции программы. С функции main всегда начинается выполнение. У функции есть имя ( main ), после имени в круглых скобках перечисляются аргументы или параметры функции (в данном случае у функции main аргументов нет). У функции может быть результат или возвращаемое значение. Если функция не возвращает никакого значения, то это обозначается ключевым словом void. В фигурных скобках записывается тело функции – действия, которые она выполняет. Оператор return 1 означает, что функция возвращает результат – целое число 1.

Если мы говорим об объектно-ориентированной программе, то она должна создать объект какого-либо класса и послать ему сообщение. Чтобы не усложнять программу, мы воспользуемся одним из готовых, предопределенных классов – классом iostream (поток ввода-вывода, базовый класс для iostream). Этот класс определен в файле заголовков " iostream.h ". Поэтому первое, что надо сделать – включить файл заголовков в нашу программу:

#include <iostream.h>
int main() { return 1; }

Кроме класса, файл заголовков определяет глобальный объект этого класса cout. Объект называется глобальным, поскольку доступ к нему возможен из любой части программы. Этот объект выполняет вывод на консоль. В функции main мы можем к нему обратиться и послать ему сообщение:

#include <iostream.h>
int main()
{
   cout << "Hello, world!" << endl;
   return 1;
}

Операция сдвига << для класса iostream определена как "вывести". Таким образом, программа посылает объекту cout сообщения "вывести строку Hello, world!" и "вывести перевод строки" ( endl обозначает новую строку). В ответ на эти сообщения объект cout выведет строку " Hello, world!" на консоль и переведет курсор на следующую строку.
** Компиляция и выполнение программы

Программа на языке Си++ – это текст. С помощью произвольного текстового редактора программист записывает инструкцию, в соответствии с которой компьютер будет работать, выполняя данную программу.

Для того чтобы компьютер мог выполнить программу, написанную на языке Си++, ее нужно перевести на язык машинных инструкций. Эту задачу решает компилятор. Компилятор читает файл с текстом программы, анализирует ее, проверяет на предмет возможных ошибок и, если таковых не обнаружено, создает исполняемый файл, т.е. файл с машинными инструкциями, который можно выполнять.

Откомпилировав программу один раз, ее можно выполнять многократно, с различными исходными данными.

Не имея возможности описать все варианты, остановимся только на двух наиболее часто встречающихся.
** Компилирование и выполнение программ в среде Windows

Если Вы используете персональный компьютер с операционной системой Microsoft \copyright Windows 98 \text{\texttrademark}, Windows NT \text{\texttrademark} или Windows 2000 \text{\texttrademark}, то компилятор у Вас, скорее всего, Visual C++ \copyright. Этот компилятор представляет собой интегрированную среду программирования, т.е. объединяет текстовый редактор, компилятор, отладчик и еще ряд дополнительных программ. Мы предполагаем, что читатель работает с версией 5.0 или старше. Версии младше 4.2 изучать не имеет смысла, поскольку реализация слишком сильно отличается от стандарта языка.

В среде Visual C++ прежде всего необходимо создать новый проект. Для этого нужно выбрать в меню File атрибут New. Появится новое диалоговое окно. В закладке Projects в списке различных типов выполняемых файлов выберите Win32 Console Application. Убедитесь, что отмечена кнопка Create new workspace. Затем следует набрать имя проекта (например, test ) в поле Project name и имя каталога, в котором будут храниться все файлы, относящиеся к данному проекту, в поле Location. После этого нажмите кнопку " OK ".

Теперь необходимо создать файл. Опять в меню File выберите атрибут New. В появившемся диалоге в закладке File отметьте text file. По умолчанию новый файл будет добавлен к текущему проекту test, в чем можно убедиться, взглянув на поле Add to project. В поле Filename нужно ввести имя файла. Пусть это будет main.cpp. Расширение .cpp – это стандарт для файлов с исходными текстами на языке Си++. Поле Location должно показывать на каталог C:\Work. Нажмите кнопку " OK ".

На экране появится пустой файл. Наберите текст программы.

Компиляция выполняется с помощью меню Build. Выберите пункт Build test.exe (этому пункту меню соответствует функциональная клавиша F7 ). В нижней части экрана появятся сообщения компиляции. Если Вы сделали опечатку, двойной щелчок мышью по строке с ошибкой переведет курсор в окне текстового редактора на соответствующую строку кода. После исправления всех ошибок и повторной компиляции система выдаст сообщение об успешной компиляции и компоновке (пока мы не будем уточнять, просто вы увидите сообщение Linking ).

Готовую программу можно выполнить с помощью меню Build, пункт Execute test.exe. То же самое можно сделать, нажав одновременно клавиши CTRL и F5. На экране монитора появится консольное окно, и в нем будет выведена строка " Hello, world!". Затем появится надпись "Press any key to continue". Эта надпись означает, что программа выполнена и лишь ожидает нажатия произвольной клавиши, чтобы закрыть консольное окно.
Компилирование и выполнение программ в среде Unix

Если Вы работаете в операционной системе Unix, то, скорее всего, у Вас нет интегрированной среды разработки программ. Вы будете пользоваться любым доступным текстовым редактором для того, чтобы набирать тексты программ.

Редактор Emacs предпочтительнее, поскольку в нем есть специальный режим редактирования программ на языке Си++. Этот режим включается автоматически при редактировании файла с именем, оканчивающимся на " .cpp " или " .h ". Но при отсутствии Emacs сгодится любой текстовый редактор.

Первое, что надо сделать – это поместить текст программы в файл. В редакторе следует создать файл с именем main.cpp (расширение cpp используется для текстов программ на языке Си++). Наберите текст программы из предыдущего параграфа и сохраните файл.

Теперь программу надо откомпилировать. Команда вызова компилятора зависит от того, какой компилятор Си++ установлен на компьютере. Если используется компилятор GNU C++, команда компиляции выглядит так:

gcc main.cpp

Вместо gcc может использоваться g++, c++, cc. Уточнить это можно у системного администратора. Отметим, что у широко распространенного компилятора GNU C++ есть ряд отличий от стандарта ISO.

В случае каких-либо ошибок в программе компилятор выдаст на терминал сообщение с указанием номера строки, где обнаружена ошибка. Если в программе нет никаких опечаток, компилятор должен создать исполняемый файл с именем a.out. Выполнить его можно, просто набрав имя a.out в ответ на подсказку интерпретатора команд:

a.out

Результатом выполнения будет вывод на экран терминала строки:

Hello, world!
* 2. Лекция: Имена, переменные и константы
Страницы: 1 | 2 | вопросы | » 	для печати и PDA
Если Вы заметили ошибку - сообщите нам или выделите ее и нажмите Ctrl+Enter
	
Правила именования переменных и функций языка, правила записи констант. Понятие ключевого или зарезервированного слова, список ключевых слов Си++.
Содержание

    Имена
    Переменные
    Константы

** Имена

Для символического обозначения величин, имен функций и т.п. используются имена или идентификаторы .

Идентификаторы в языке Си++ – это последовательность знаков, начинающаяся с буквы или знака подчеркивания. В идентификаторах можно использовать заглавные и строчные латинские буквы, цифры и знак подчеркивания. Длина идентификаторов произвольная. Примеры правильных идентификаторов:

abc A12 NameOfPerson    BYTES_PER_WORD

Отметим, что abc и Abc – два разных идентификатора, т.е. заглавные и строчные буквы различаются. Примеры неправильных идентификаторов:

12X a-b

Ряд слов в языке Си++ имеет особое значение и не может использоваться в качестве идентификаторов. Такие зарезервированные слова называются ключевыми.

Список ключевых слов:

№ п/п Ключевое слово Описание 
1	and	альтернатива оператору && 
2	and_eq	альтернатива оператору &= 
3	asm	вставить код на ассемблере 
4	auto	объявить локальную переменную 
5	bitand	альтернатива оператору bitwise & 
6	bitor	альтернатива оператору | 
7	bool	объявить булеву переменную 
8	break	выйти с цикла 
9	case	определенная ветка в операторе ветвления switch 
10	catch	обработать исключение от throw 
11	char	объявить символьную переменную 
12	class	объявить класс 
13	compl	альтернатива оператору ~ 
14	const	объявить неизменяемые данные или функцию, которая не изменяет данных 
15	const_cast	приведение типа от константной переменной 
16	continue	пропустить код до конца цикла и начать новую итерацию 
17	default	вариант по умолчанию в switch 
18	delete	освобождение памяти, выделенной new 
19	do	оператор цикла 
20	double	объявить вещественное число двойной точности 
21	dynamic_cast	выполнить приведение типов во время выполнения 
22	else	ветка оператора if, которая выполняется при ложном условии 
23	enum	создание перечисляемого типа 
24	explicit	использовать данный конструктор только при полном соответствии типов 
25	export	позволить разделить объявление и реализацию шаблона 
26	extern	указание компилятору, что переменная объявлена в другом файле 
27	false	константа для ложного значения булевой переменной 
28	float	объявить вещественную переменную 
29	for	оператор цикла 
30	friend	разрешить другим функциям доступ к приватным данным класса 
31	goto	безусловный переход 
32	if	оператор условия 
33	inline	оптимизация вызовов для функций (встраиваемые функции) 
34	int	объявить переменную целого типа 
35	long	объявить следующий тип длинным 
36	mutable	перекрыть константность 
37	namespace	определить новое пространство имен 
38 	new	выделить динамическую память под новую переменную 
39	not	альтернатива оператору ! 
40	not_eq	альтернатива оператору != 
41	operator	создание перегруженных операторов 
42	or	альтернатива оператору || 
43	or_eq	альтернатива оператору |= 
44	private	объявить приватное поле класса 
45	protected	объявить защищенное поле класса 
46	public	объявить общее поле класса 
47	register	запрос компилятору на оптимизацию переменной по скорости 
48	reinterpret_cast	изменить тип переменной 
49	return	возврат из функции 
50	short	объявить короткое целое 
51	signed	сделать данный целый тип знаковым 
52	sizeof	возвратить размер переменной или типа 
53	static	создать статическую переменную 
54	static_cast	сделать не полиморфное приведение типов 
55	struct	определить новую структуру 
56	switch	оператор ветвления 
57	template	создать шаблонную функцию 
58	this	указатель на текущий объект 
59	throw	выбросить исключение 
60	true	константа для истинного значения булевой переменной 
61	try	выполнить код, который может выкинуть исключение 
62	typedef	создание нового типа с существующего 
63	typeid	задать описание объекта 
64	typename	объявить класс или иной новый тип данных 
65	union	структура, содержащая несколько переменных в одной области памяти 
66	unsigned	объявить беззнаковое целое 
67	using	импортировать полностью или частично указанное пространство имен внутрь текущего блока 
68	virtual	создать виртуальную функцию 
69	void	объявить функцию или переменную без типа 
70	volatile	предупреждение компилятору, что переменная может измениться сама 
71	wchar_t	объявить переменную типа wide-character 
72	while	оператор цикла 
73	xor	альтернатива оператору ^ 
74	xor_eq	альтернатива оператору ^=

В следующем примере

int max(int x, int y) 
{
    if (x > y)
        return x;
    else
        return y;
}

max, x и y – имена или идентификаторы. Слова int, if, return и else – ключевые слова, они не могут быть именами переменных или функций и используются для других целей.
** Переменные

Программа оперирует информацией, представленной в виде различных объектов и величин. Переменная – это символическое обозначение величины в программе. Как ясно из названия, значение   переменной (или величина, которую она обозначает) во время выполнения программы может изменяться.

С точки зрения архитектуры компьютера, переменная – это символическое обозначение ячейки оперативной памяти программы, в которой хранятся данные. Содержимое этой ячейки – это текущее значение переменной.

В языке Си++ прежде чем использовать переменную, ее необходимо объявить. Объявить переменную с именем   x можно так:

int x;

В объявлении первым стоит название типа переменной   int (целое число), а затем идентификатор   x – имя переменной. У переменной   x есть тип – в данном случае целое число. Тип переменной определяет, какие возможные значения эта переменная может принимать и какие операции можно выполнять над данной переменной. Тип переменной изменить нельзя, т.е. пока переменная   x существует, она всегда будет целого типа.

Язык Си++ – это строго типизированный язык. Любая величина, используемая в программе, принадлежит к какому-либо типу. При любом использовании переменных в программе проверяется, применимо ли выражение или операция к типу переменной. Довольно часто смысл выражения зависит от типа участвующих в нем переменных.

Например, если мы запишем x+y, где x – объявленная выше переменная, то переменная y должна быть одного из числовых типов.

Соответствие типов проверяется во время компиляции программы. Если компилятор обнаруживает несоответствие типа переменной и ее использования, он выдаст ошибку (или предупреждение). Однако во время выполнения программы типы не проверяются. Такой подход, с одной стороны, позволяет обнаружить и исправить большое количество ошибок на стадии компиляции, а, с другой стороны, не замедляет выполнения программы.

Переменной можно присвоить какое-либо значение с помощью операции присваивания. Присвоить – это значит установить текущее значение переменной. По-другому можно объяснить, что операция присваивания запоминает новое значение в ячейке памяти, которая обозначена переменной.

int x;      // объявить целую переменную x
int y;      // объявить целую переменную y
x = 0;      // присвоить x значение 0
y = x + 1;  // присвоить y значение x + 1, 
            // т.е. 1
x = 1;      // присвоить x значение 1
y = x + 1;  // присвоить y значение x + 1, 
            // теперь уже 2
** Константы

В программе можно явно записать величину – число, символ и т.п. Например, мы можем записать выражение x + 4 – сложить текущее значение переменной   x и число 4. В зависимости от того, при каких условиях мы будем выполнять программу, значение переменной   x может быть различным. Однако целое число четыре всегда останется прежним. Это неизменяемая величина или константа.

Таким образом, явная запись значения в программе – это константа.

Далеко не всегда удобно записывать константы в тексте программы явно. Гораздо чаще используются символические константы. Например, если мы запишем

const int BITS_IN_WORD = 32;

то затем имя   BITS_IN_WORD можно будет использовать вместо целого числа 32.

Преимущества такого подхода очевидны. Во-первых, имя   BITS_IN_WORD (битов в машинном слове) дает хорошую подсказку, для чего используется данное число. Без комментариев понятно, что выражение

b / BITS_IN_WORD

(значение b разделить на число 32 ) вычисляет количество машинных слов, необходимых для хранения b битов информации. Во-вторых, если по каким-либо причинам нам надо изменить эту константу, потребуется изменить только одно место в программе – определение константы, оставив все случаи ее использования как есть. (Например, мы переносим программу на компьютер с другой длиной машинного слова.)
* 3. Лекция: Операции и выражения

Правила формирования и вычисления выражений в языке Си++. Все операции языка.
Содержание

    Выражения
    Операция присваивания
    Все операции языка Си++
        Арифметические операции
        Операции сравнения
        Логические операции
        Битовые операции
        Условная операция
        Последовательность
        Операции присваивания
    Порядок вычисления выражений

** Выражения

Программа оперирует с данными. Числа можно складывать, вычитать, умножать, делить. Из разных величин можно составлять выражения, результат вычисления которых – новая величина. Приведем примеры выражений:

X * 12 + Y  // значение X умножить на 12 и к результату прибавить значение Y
val < 3     // сравнить значение val с 3
-9          // константное выражение -9

Выражение, после которого стоит точка с запятой – это оператор-выражение. Его смысл состоит в том, что компьютер должен выполнить все действия, записанные в данном выражении, иначе говоря, вычислить выражение.

x + y – 12; // сложить значения x и y и затем вычесть 12
a = b + 1;  // прибавить единицу к значению b и запомнить результат в переменной a

Выражения – это переменные, функции и константы, называемые операндами, объединенные знаками операций. Операции могут быть унарными – с одним операндом, например, минус; могут быть бинарные – с двумя операндами, например сложение или деление. В Си++ есть даже одна операция с тремя операндами – условное выражение. Чуть позже мы приведем список всех операций языка Си++ для встроенных типов данных. Подробно каждая операция будет разбираться при описании соответствующего типа данных. Кроме того, ряд операций будет рассмотрен в разделе, посвященном определению операторов для классов. Пока что мы ограничимся лишь общим описанием способов записи выражений.

В типизированном языке, которым является Си++, у переменных и констант есть определенный тип. Есть он и у результата выражения. Например, операции сложения ( + ), умножения ( * ), вычитания ( - ) и деления ( / ), примененные к целым числам, выполняются по общепринятым математическим правилам и дают в результате целое значение. Те же операции можно применить к вещественным числам и получить вещественное значение.

Операции сравнения: больше ( > ), меньше ( < ), равно ( == ), не равно ( != ) сравнивают значения чисел и выдают логическое значение: истина ( true ) или ложь ( false ).
** Операция присваивания

Присваивание – это тоже операция, она является частью выражения. Значение правого операнда присваивается левому операнду.

x = 2;        // переменной x присвоить значение 2
cond = x < 2; // переменной cond присвоить значение true, если x меньше 2, 
              // в противном случае присвоить значение false
3 = 5;        // ошибка, число 3 неспособно изменять свое значение

Последний пример иллюстрирует требование к левому операнду операции присваивания. Он должен быть способен хранить и изменять свое значение. Переменные, объявленные в программе, обладают подобным свойством. В следующем фрагменте программы

int x = 0;
x = 3;
x = 4;
x = x + 1;

вначале объявляется переменная x с начальным значением 0. После этого значение x изменяется на 3, 4 и затем 5. Опять-таки, обратим внимание на последнюю строчку. При вычислении операции присваивания сначала вычисляется правый операнд, а затем левый. Когда вычисляется выражение x + 1, значение переменной x равно 4. Поэтому значение выражения x + 1 равно 5. После вычисления операции присваивания (или, проще говоря, после присваивания ) значение переменной x становится равным 5.

У операции присваивания тоже есть результат. Он равен значению левого операнда. Таким образом, операция присваивания может участвовать в более сложном выражении:

z = (x = y + 3);

В приведенном примере переменным x и z присваивается значение y + 3.

Очень часто в программе приходится значение переменной увеличивать или уменьшать на единицу. Для того чтобы сделать эти действия наиболее эффективными и удобными для использования, применяются предусмотренные в Си++ специальные знаки операций: ++ (увеличить на единицу) и -- (уменьшить на единицу). Существует две формы этих операций: префиксная и постфиксная. Рассмотрим их на примерах.

int x = 0;
++x;

Значение x увеличивается на единицу и становится равным 1.

--x;

Значение x уменьшается на единицу и становится равным 0.

int y = ++x;

Значение x опять увеличивается на единицу. Результат операции ++ – новое значение x, т.е. переменной y присваивается значение 1.

int z = x++;

Здесь используется постфиксная запись операции увеличения на единицу. Значение переменной x до выполнения операции равно 1. Сама операция та же – значение x увеличивается на единицу и становится равным 2. Однако результат постфиксной операции – это значение аргумента до увеличения. Таким образом, переменной z присваивается значение 1. Аналогично, результатом постфиксной операции уменьшения на единицу является начальное значение операнда, а префиксной – его конечное значение.

Подобными мотивами оптимизации и сокращения записи руководствовались создатели языка Си (а затем и Си++), когда вводили новые знаки операций типа "выполнить операцию и присвоить". Довольно часто одна и та же переменная используется в левой и правой части операции присваивания, например:

x = x + 5;
y = y * 3;
z = z – (x + y);

В Си++ эти выражения можно записать короче:

x += 5;
y *= 3;
z -= x + y;

Т.е. запись oper= означает, что левый операнд вначале используется как левый операнд операции oper, а затем как левый операнд операции присваивания результата операции oper. Кроме краткости выражения, такая запись облегчает оптимизацию программы компилятором.
** Все операции языка Си++

Наряду с общепринятыми арифметическими и логическими операциями, в языке Си++ имеется набор операций для работы с битами – поразрядные И, ИЛИ, ИСКЛЮЧАЮЩЕЕ ИЛИ и НЕ, а также сдвиги.

Особняком стоит операция sizeof. Эта операция позволяет определить, сколько памяти занимает то или иное значение. Например:

sizeof(long);    
// сколько байтов занимает тип long

sizeof (b);        
// сколько байтов занимает переменная b

Операция sizeof в качестве аргумента берет имя типа или выражение. Аргумент заключается в скобки (если аргумент – выражение, скобки не обязательны). Результат операции – целое число, равное количеству байтов, которое необходимо для хранения в памяти заданной величины.

Ниже приводятся все операции языка Си++.
** Арифметические операции

+ сложение
- вычитание
 * умножение
/ деление

Операции сложения, вычитания, умножения и деления целых и вещественных чисел. Результат операции – число, по типу соответствующее большему по разрядности операнду. Например, сложение чисел типа short и long в результате дает число типа long.

% остаток

Операция нахождения остатка от деления одного целого числа на другое. Тип результата – целое число.

- минус
+ плюс

Операция "минус" – это унарная операция, при которой знак числа изменяется на противоположный. Она применима к любым числам со знаком. Операция "плюс" существует для симметрии. Она ничего не делает, т.е. примененная к целому числу, его же и выдает.

++ увеличить на единицу, префиксная и 
   постфиксная формы
-- уменьшить на единицу, префиксная и 
   постфиксная формы

Эти операции иногда называют "автоувеличением" (инкремент) и "автоуменьшением" (декремент). Они увеличивают (или, соответственно, уменьшают) операнд на единицу. Разница между постфиксной (знак операции записывается после операнда, например x++ ) и префиксной (знак операции записывается перед операндом, например --y ) операциями заключается в том, что в первом случае результатом является значение операнда до изменения на единицу, а во втором случае – после изменения на единицу.
** Операции сравнения

== равно
!= не равно
< меньше
> больше
<= меньше или равно
>= больше или равно

Операции сравнения. Сравнивать можно операнды любого типа, но либо они должны быть оба одного и того же встроенного типа ( сравнение на равенство и неравенство работает для двух величин любого типа), либо между ними должна быть определена соответствующая операция сравнения. Результат – логическое значение true или false.
** Логические операции

&& логическое И
|| логическое ИЛИ
! логическое НЕ

Логические операции конъюнкции, дизъюнкции и отрицания. В качестве операндов выступают логические значения, результат – тоже логическое значение true или false .
** Битовые операции

& битовое И
| битовое ИЛИ
^ битовое ИСКЛЮЧАЮЩЕЕ ИЛИ
~ битовое НЕ

Побитовые операции над целыми числами. Соответствующая операция выполняется над каждым битом операндов. Результатом является целое число.

<< сдвиг влево
>> сдвиг вправо

Побитовый сдвиг левого операнда на количество разрядов, соответствующее значению правого операнда. Результатом является целое число.
** Условная операция

операнд1?операнд2:операнд3

Тернарная операция ; если значение первого операнда – истина, то результат – второй операнд; если ложь – результат – третий операнд. Первый операнд должен быть логическим значением, второй и третий операнды могут быть любого, но одного и того же типа, а результат будет того же типа, что и третий операнд.
** Последовательность

, последовательность

Выполнить выражение до запятой, затем выражение после запятой. Два произвольных выражения можно поставить рядом, разделив их запятой. Они будут выполняться последовательно, и результатом всего выражения будет результат последнего выражения.
** Операции присваивания

= присваивание

Присвоить значение правого операнда левому. Результат операции присваивания – это значение правого операнда.

+=, -=, *=, /=, %=, |=, &=, ^=, <<=, >>= 
выполнить операцию и присвоить

Выполнить соответствующую операцию с левым операндом и правым операндом и присвоить результат левому операнду. Типы операндов должны быть такими, что, во-первых, для них должна быть определена соответствующая арифметическая операция, а во-вторых, результат может быть присвоен левому операнду.
** Порядок вычисления выражений

У каждой операции имеется приоритет. Если в выражении несколько операций, то первой будет выполнена операция с более высоким приоритетом. Если же операции одного и того же приоритета, они выполняются слева направо.

Например, в выражении

2 + 3 * 6

сначала будет выполнено умножение, а затем сложение ;соответственно, значение этого выражения — число 20.

В выражении

2 * 3 + 4 * 5

сначала будет выполнено умножение, а затем сложение. В каком порядке будет производиться умножение – сначала 2 * 3, а затем 4 * 5 или наоборот, не определено. Т.е. для операции сложения порядок вычисления ее операндов не задан.

В выражении

x = y + 3

вначале выполняется сложение, а затем присваивание, поскольку приоритет    операции присваивания ниже, чем приоритет операции сложения.

Для данного правила существует исключение: если в выражении несколько операций присваивания, то они выполняются справа налево. Например, в выражении

x = y = 2

сначала будет выполнена операция присваивания значения 2 переменной y. Затем результат этой операции – значение 2 – присваивается переменной x.

Ниже приведен список всех операций в порядке понижения приоритета. Операции с одинаковым приоритетом выполняются слева направо (за исключением нескольких операций присваивания ).

:: (разрешение области видимости имен)

. (обращение к элементу класса), -> (обращение к элементу класса по указателю), [] (индексирование), вызов функции, ++ (постфиксное увеличение на единицу), -- (постфиксное уменьшение на единицу), typeid (нахождение типа), dynamic_cast static_cast reinterpret_cast const_cast (преобразования типа)

sizeof (определение размера), ++ (префиксное увеличение на единицу), -- (префиксное уменьшение на единицу), ~ (битовое НЕ), ! (логическое НЕ), – (изменение знака), + (плюс), & (взятие адреса), * (обращение по адресу), new (создание объекта), delete (удаление объекта), (type) (преобразование типа)

.*, ->* (обращение по указателю на элемент класса)

 * ( умножение ), / ( деление ), % ( остаток )

+ ( сложение ), – ( вычитание )

<< , >> ( сдвиг )

< <= > >= ( сравнения на больше или меньше)

== != (равно, неравно)

& (поразрядное И)

^ (поразрядное исключающее ИЛИ)

 | (поразрядное ИЛИ)

&& (логическое И)

 || (логическое ИЛИ)

= ( присваивание ), *= /= %= += -= <<= >>= &= |= ^= (выполнить операцию и присвоить)

?: (условная операция)

, ( последовательность )

Для того чтобы изменить последовательность вычисления выражений, можно воспользоваться круглыми скобками. Часть выражения, заключенная в скобки, вычисляется в первую очередь. Значением

(2 + 3) * 6

будет 30.

Скобки могут быть вложенными, соответственно, самые внутренние выполняются первыми:

(2 + (3 * (4 + 5) ) – 2)
* 4. Лекция: Операторы

Описываются все операторы управления, имеющиеся в языке Си++, даются примеры их использования.
Содержание

    Что такое оператор
        Операторы-выражения
        Объявления имен
        Операторы управления
            Условные операторы
            Операторы цикла
            Оператор возврата
            Оператор перехода

** Что такое оператор

Запись действий, которые должен выполнить компьютер, состоит из операторов. При выполнении программы операторы выполняются один за другим, если только оператор не является оператором управления, который может изменить последовательное выполнение программы.

Различают операторы объявления имен, операторы управления и операторы-выражения.
Операторы-выражения

Выражения мы рассматривали в предыдущей лекции. Выражение, после которого стоит точка с запятой, – это оператор-выражение. Его смысл состоит в том, что компьютер должен выполнить все действия, записанные в данном выражении, иначе говоря, вычислить выражение. Чаще всего в операторе-выражении стоит операция присваивания или вызов функции. Операторы выполняются последовательно, и все изменения значений переменных, сделанные в предыдущем операторе, используются в последующих.

a  =  1;
b  =  3;
m  =  max(a,  b);

Переменной a присваивается значение 1, переменной b – значение 3. Затем вызывается функция max с параметрами 1 и 3, и ее результат присваивается переменной m.

Как мы уже отмечали, присваивание – необязательная операция в операторе-выражении. Следующие операторы тоже вполне корректны:

x + y – 12;     // сложить значения x и y и 
                // затем вычесть 12
func(d, 12, x);	// вызвать функцию func с 
                // заданными параметрами

Объявления имен

Эти операторы объявляют имена, т.е. делают их известными программе. Все идентификаторы или имена, используемые в программе на языке Си++, должны быть объявлены.

Оператор объявления состоит из названия типа и объявляемого имени:

int  x;         // объявить целую переменную x
double f;       // объявить переменную f типа 
                // double
const float pi = 3.1415;  
     // объявить константу pi типа float
     // со значением 3.1415

Оператор объявления заканчивается точкой с запятой.
** Операторы управления

Операторы управления определяют, в какой последовательности выполняется программа. Если бы их не было, операторы программы всегда выполнялись бы последовательно, в том порядке, в котором они записаны.
*** Условные операторы

Условные операторы позволяют выбрать один из вариантов выполнения действий в зависимости от каких-либо условий. Условие – это логическое выражение, т.е. выражение, результатом которого является логическое значение true (истина) или false (ложь).

Оператор if выбирает один из двух вариантов последовательности вычислений.

if   (условие)
     оператор1
else
     оператор2

Если условие истинно, выполняется оператор1, если ложно, то выполняется оператор2.

if   (x > y)
     a = x;
else
     a = y;

В данном примере переменной a присваивается значение максимума из двух величин x и y.

Конструкция else необязательна. Можно записать:

if   (x < 0)
     x = -x;
abs = x;

В данном примере оператор x = -x; выполняется только в том случае, если значение переменной x было отрицательным. Присваивание переменной abs выполняется в любом случае. Таким образом, приведенный фрагмент программы изменит значение переменной x на его абсолютное значение и присвоит переменной abs новое значение x.

Если в случае истинности условия необходимо выполнить несколько операторов, их можно заключить в фигурные скобки:

if   (x < 0) {
     x = -x;
     cout << "Изменить значение x на 
	      противоположное по знаку";
}
abs = x;

Теперь если x отрицательно, то не только его значение изменится на противоположное, но и будет выведено соответствующее сообщение. Фактически, заключая несколько операторов в фигурные скобки, мы сделали из них один сложный оператор или блок. Прием заключения нескольких операторов в блок работает везде, где нужно поместить несколько операторов вместо одного.

Условный оператор можно расширить для проверки нескольких условий:

if   (x  < 0)
     cout  << "Отрицательная величина";
else if   (x > 0)
     cout  << "Положительная величина";
else
     cout  << "Ноль";

Конструкций else if может быть несколько.

Хотя любые комбинации условий можно выразить с помощью оператора if, довольно часто запись становится неудобной и запутанной. Оператор выбора switch используется, когда для каждого из нескольких возможных значений выражения нужно выполнить определенные действия. Например, предположим, что в переменной code хранится целое число от 0 до 2, и нам нужно выполнить различные действия в зависимости от ее значения:

switch (code) {
case 0:
     cout << "код ноль";
     x = x + 1;
     break;
case 1 :
     cout << "код один";
     y = y + 1;
     break;
case 2:
     cout << "код два";
     z = z + 1;
     break;
default:
     cout << "Необрабатываемое значение";
}

В зависимости от значения code управление передается на одну из меток case. Выполнение оператора заканчивается по достижении либо оператора break, либо конца оператора switch. Таким образом, если code равно 1, выводится " код один ", а затем переменная y увеличивается на единицу. Если бы после этого не стоял оператор break, то управление "провалилось" бы дальше, была бы выведена фраза " код два ", и переменная z тоже увеличилась бы на единицу.

Если значение переключателя не совпадает ни с одним из значений меток case, то выполняются операторы, записанные после метки default. Метка default может быть опущена, что эквивалентно записи:

default:
   ;  // пустой оператор, не выполняющий 
      // никаких действий

Очевидно, что приведенный пример можно переписать с помощью оператора if:

if   (code == 0) {
     cout << "код ноль";
     x = x + 1;
} else if (code == 1) {
     cout << "код один";
     y = y + 1;
} else if (code == 2) {
     cout << "код два";
     z = z + 1;
} else {
     cout << "Необрабатываемое значение";
}

Пожалуй, запись с помощью оператора переключения switch более наглядна. Особенно часто переключатель используется, когда значение выражения имеет тип набора.

*** Операторы цикла

Предположим, нам нужно вычислить сумму всех целых чисел от 0 до 100. Для этого воспользуемся оператором цикла for:

int sum = 0;
int i;
for (i = 1; i <= 100; i = i + 1)	
                         // заголовок цикла
     sum = sum + i;      // тело цикла

Оператор цикла состоит из заголовка цикла и тела цикла. Тело цикла – это оператор, который будет повторно выполняться (в данном случае – увеличение значения переменной sum на величину переменной i ). Заголовок – это ключевое слово for, после которого в круглых скобках записаны три выражения, разделенные точкой с запятой. Первое выражение вычисляется один раз до начала выполнения цикла. Второе – это условие цикла. Тело цикла будет повторяться до тех пор, пока условие цикла истинно. Третье выражение вычисляется после каждого повторения тела цикла.

Оператор for реализует фундаментальный принцип вычислений в программировании – итерацию. Тело цикла повторяется для разных, в данном случае последовательных, значений переменной i. Повторение иногда называется итерацией. Мы как бы проходим по последовательности значений переменной i, выполняя с текущим значением одно и то же действие, тем самым постепенно вычисляя нужное значение. С каждой итерацией мы подходим к нему все ближе и ближе. С другим принципом вычислений в программировании – рекурсией – мы познакомимся в разделе, описывающем функции.

Любое из трех выражений в заголовке цикла может быть опущено (в том числе и все три). То же самое можно записать следующим образом:

int sum = 0;
int i = 1;
for (; i <= 100; ) {
     sum = sum + i;
     i = i + 1;
}

Заметим, что вместо одного оператора цикла мы записали несколько операторов, заключенных в фигурные скобки – блок. Другой вариант:

int sum = 0;
int i = 1;
for (; ;) {
     if (i > 100)
          break;
     sum = sum + i;
     i = i + 1;
}

В последнем примере мы опять встречаем оператор break. Оператор break завершает выполнение цикла. Еще одним вспомогательным оператором при выполнении циклов служит оператор продолжения continue. Оператор continue заставляет пропустить остаток тела цикла и перейти к следующей итерации (повторению). Например, если мы хотим найти сумму всех целых чисел от 0 до 100, которые не делятся на 7, можно записать это так:

int sum = 0;
for (int i = 1; i <= 100; i = i+1) {
     if ( i % 7 == 0)
          continue;
     sum = sum + i;
}

Еще одно полезное свойство цикла for: в первом выражении заголовка цикла можно объявить переменную. Эта переменная будет действительна только в пределах цикла.

Другой формой оператора цикла является оператор while. Его форма следующая:

while (условие)
     оператор

Условие – как и в условном операторе if – это выражение, которое принимает логическое значение "истина" или "ложь". Выполнение оператора повторяется до тех пор, пока значением условия является true (истина). Условие вычисляется заново перед каждой итерацией. Подсчитать, сколько десятичных цифр нужно для записи целого положительного числа N, можно с помощью следующего фрагмента:

int digits =0;
while (N >= 1) {
     digits = digits + 1;
     N = N / 10;
}

Третьей формой оператора цикла является цикл do while. Он имеет форму:

do { операторы } while ( условие);

Отличие от предыдущей формы цикла while заключается в том, что условие проверяется после выполнения тела цикла. Предположим, требуется прочитать символы с терминала до тех пор, пока не будет введен символ "звездочка".

char ch;
do {
   ch = getch();  // функция getch возвращает
                  // символ, введёный с 
                  // клавиатуры
} while (ch != '*');

В операторах while и do также можно использовать операторы break и continue.

Как легко заметить, операторы цикла взаимозаменяемы. Оператор while соответствует оператору for:

for  ( ; условие ; )
     оператор

Пример чтения символов с терминала можно переписать в виде:

char ch;
ch = getch(); 
while (ch != '*') {
     ch = getch();
}

Разные формы нужны для удобства и наглядности записи.
*** Оператор возврата

Оператор return завершает выполнение функции и возвращает управление в ту точку, откуда она была вызвана. Его форма:

return выражение;

Где выражение – это результат функции. Если функция не возвращает никакого значения, то оператор возврата имеет форму

return;

*** Оператор перехода

Последовательность выполнения операторов в программе можно изменить с помощью оператора перехода goto. Он имеет вид:

goto метка;

Метка ставится в программе, записывая ее имя и затем двоеточие. Например, вычислить абсолютную величину значения переменной x можно следующим способом:

if ( x >= 0)
  goto positiv;
x = -x;        // переменить знак x
positiv:       // объявление метки
abs = x;       // присвоить переменной abs
               // положительное значение

При выполнении goto вместо следующего оператора выполняется оператор, стоящий после метки positiv. Если значение x положительное, оператор x = - x выполняться не будет.

В настоящее время считается, что оператор goto очень легко запутывает программу. Без него, вообще говоря, можно обойтись, поэтому лучше его не использовать, ну разве что лишь в самом крайнем случае.

Пример:

int fact(int n)
{
     int k;
     if (n == 1) {
          k = 1;
     } else {
          k = n * fact(n – 1);
     }
     return k;
}

Это функция вычисления факториала. Первый оператор в ней – это объявление переменной k, в которой будет храниться результат вычисления. Затем выполняется условный оператор if. Если n равно единице, то вычисления факториала закончены, и выполняется оператор-выражение, который присваивает переменной значение 1. В противном случае выполняется другой оператор-выражение.

Последний оператор – это оператор возврата из функции.
